#!/usr/bin/python
# -*- coding: utf-8 -*-
try:
  import sys
except Exception, e:
  print "Could not load ''sys'': %s" %(e)
  exit(1)

try:
  import os
  from argparse import ArgumentParser
  import inspect
  import re
  import codecs
  import unicodedata
  import json

  sys.path.append("%s/.." %(os.path.dirname(os.path.realpath(os.path.abspath(__file__))))) # Ho ho ho!
  from libcmdb2.core import CMDBServer, resources
  from libcmdb2.resources.common import Resource

  from cmdbtool import *

#  print "%s" %(sys.path)

except Exception, e:
  print "Could not load: %s" %(e)
  exit(1)

# Husk: "requests"

__version__ = '0.0.1'
__author__ = u'Erlend Bergs√•s <erlend.bergsaas@met.no>'

###
# Some configuration. hrm... Hardcoding rox
default_output = {
  'host': ["name", ["item", "serial"]]
}

# Compile ''query''
# This is DIRTY. And: rather unsafe. :) Oh well.
###
# Setup argument parsing
parser = ArgumentParser(description='Drac drac drac drac!')
parser.add_argument("-r", "--resource", type=str, metavar="resource", help="Lookup specified resource.")
parser.add_argument("-F", "--follow", help="Follow resources recursively", action="store_true")
parser.add_argument("-i", "--ignore-case", help="Ignore case in searches", action="store_true")
parser.add_argument("-e", "--escapes", help="Interpret backslash escapes", action="store_true")
parser.add_argument("-o", "--output", help="Output fields")
parser.add_argument("-O", "--format", help="Output field format")
parser.add_argument("-c", "--count", help="Print count", action="store_true")
parser.add_argument("--query-limit", help="cmdb ''query limit''", type=int)
parser.add_argument("--query-offset", help="cmdb ''query offset''", type=int)
parser.add_argument("-D", "--dump", action="append", help="Dump ''resource'', ''api-base'', ''flt'', ''object'', etc.")
parser.add_argument("-d", "--dict-dump", action="append", dest="dict_dump", help="Dump api objects.")
parser.add_argument("-X", "--xdebug", action="append")

args, leftover = parser.parse_known_args()

###
# Program: begin!

client = CMDB.Client(None)
if args.xdebug:
  client.xdebug(args.xdebug)
client.__init__('http://cmdb.met.no/api/v2/')

#client = CMDB.Client('http://cmdb.met.no', '/api/v2/')

# Dump return from 
if args.dict_dump:
  for stuff in args.dict_dump:
    print json.dumps(client.get_dict(stuff, 3), indent=2)
  exit(0) 

resource = args.resource
if resource == None:
  resource = default_output.keys()[0]

if args.output != None:
  args.output = args.output.split(",")
  for idx, val in enumerate(args.output):
    # Ugh. I don't know python. :)
    tmp = val.split(".")
    if (len(tmp) > 1):
      args.output[idx] = tmp

#  Dump resource
if args.dump and 'resource' in args.dump:
  print "Resource: %s" %(resource)
  rs = client.cache_resource(resource).resource_schema

  for attr in rs:
    print("  %s\n    %s (%s)"%(attr, rs[attr]["help_text"],rs[attr]["type"]))
  
  exit(0)

#  Dump api base
if args.dump and 'api-base' in args.dump:
  print "Api base, baby."
  api_base = client.server._api_base
  for resource in api_base:
    print(resource)
  
  exit(0)

#  Dump "field looku ptypes"
if args.dump and 'flt' in args.dump:
  print "Flt baby (field lookup type!)"
  print client.server.field_lookup_types
  exit(0)

resource_cache = client.cache_resource(resource)
resource_class = resource_cache.resource_class

#if args.output != None:
#  output = args.output
#else:
#  try:
#    output = default_output[resource]
#  except KeyError, e:
#    output = [resource_cache.display_name, resource_cache.pk]
output = args.output
output_sane = None

output_format = args.format
if args.escapes:
  output_format = output_format.decode('string_escape')

#if args.format == None:
#  output_format = ": %s"*len(output)
#  output_format = output_format[2:]
#else:
#  output_format = args.format

# Blurp
try:
  compiled_output = False
  search = client.init_basic_search(resource, leftover)
  # I've no idea whether this is "pythonic" or not.
  query = client.new_query(resource, **search)


  query.set_limit = args.query_limit
  query.set_offset = args.query_offset
   
  objects = 1
  try:
    while objects:
      objects = query.object_query()
        
      # Ugh I wish I could do "while objects = ..."
      if not isinstance(objects, list):
        break
        
      if args.count:
        print "Count: %d/%d" %(query.offset(), query.total_count())
      
      client.tq("printing some ''objects''")

      for obj in objects:
        obj = resource_cache.resource_class(client.server, obj)

        if args.dump and 'object' in args.dump:
          client.dump_object(obj)

        if not output:
          output = client.default_output(obj)
          
        if not output_sane:
          output_sane = client.sane_output(output, obj)

        if not output_format:
          output_format = client.generate_output_format(output_sane)
        

        if not compiled_output:
          compiled_output = client.compile_output(output_sane, obj)
          if not compiled_output:
            print "Nothing to output"
            exit(1)

        print output_format % eval(compiled_output)
      client.tq()

  except KeyboardInterrupt:
    print "Uh oh."
    raise KeyboardInterrupt

except KeyboardInterrupt:
  print "^C"
  exit(1)

exit(0)



# vim: syntax=python
