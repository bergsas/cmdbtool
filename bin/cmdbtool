#!/usr/bin/python
# -*- coding: utf-8 -*-
try:
  import sys
except Exception, e:
  print "Could not load ''sys'': %s" %(e)
  exit(1)

try:
  from argparse import ArgumentParser
  import inspect
  import re
  import codecs
  import unicodedata
  from libcmdb2.core import CMDBServer, resources
  from libcmdb2.resources.common import Resource

except Exception, e:
  print "Could not load: %s" %(e)
  exit(1)

# Husk: "requests"

__version__ = '0.0.1'
__author__ = u'Erlend Bergsås <erlend.bergsaas@met.no>'

###
# Some configuration. hrm... Hardcoding rox
reversal = {
  'host': ["item", "serial"] 
}
default_output = {
  'host': ["name", ["item", "serial"]]
}

###
# Class
class CMDB:
  class Client(object):
    class ResourceCache:
      def __init__(self, client, resource_name):
        self.client = client
        self.resource_name = resource_name
        self.resource_class = client.resources.get_class_for(resource_name)
        self.pk = self.resource_class.pk
        self.resource_schema = client.server.resource_schema(resource_name)
        self.display_name = self.resource_class.display_name_attrs
        self.required_attrs = self.resource_class.required_attrs
        self.optional_attrs = self.resource_class.optional_attrs

      def __repr__(self):
        return self.resource_name

    class Query:
      def __init__(self, client, resource):
        self.client = client
        self.resource = resource
        self.set_limit = None
        self.set_offset = None
        self.query = None
        self.uri = None

        self.json = None

        self.ready = False
      
      def make_ready(self):
        if word is None:
          self.uri = self.client.server._make_uri(self.resource)
        else:
          self.uri = self.client.server._make_uri(self.resource, **self.query)
        
        if not self.set_limit is None:
          if re.match('.*\?.*', self.uri):
            self.uri += "&limit=%d" %(self.set_limit)
          else:
            self.uri += "?limit=%d" %(self.set_limit)
 
        if not self.set_offset is None:
          if re.match('.*\?.*', self.uri):
            self.uri += "&offset=%d" %(self.set_offset)
          else:
            self.uri += "?offset=%d" %(self.set_offset)

      def object_query (self): 
        if self.uri is None:
          raise Exception("Not ready")

        if self.uri is False:
          return False

        self._dict = self.client.server._get_dict(self.uri)
        
        if 'next' in self._dict['meta'] and self._dict['meta']['next']:
          self.uri = self.client.server._server + self._dict['meta']['next']
        else:
          self.uri = False

        return self._dict['objects']
     
      def offset(self):
        return self._dict['meta']['offset']

      def limit(self):
        return self._dict['meta']['limit']

      def total_count(self):
        return self._dict['meta']['total_count']

    def new_query(self, resource, **kwargs):
      query = self.Query(self, resource)
      query.query = kwargs
      return query


    def __init__(self, server, api_path, user = None, api_key = None):
      # Initiate server object
      self.server = CMDBServer(server, api_path, user, api_key)
      self.resources = resources 
      self.resource_cache = {}
    
    def __repr__(self):
      return str(self.server._server)

    # Ugh
    def unicode_fallback(self, string):
      return unicodedata.normalize('NFKD', string).encode('ascii', 'ignore')

    # This is probably a very expensive way of doing it!
    def cache_resource(self, resource_name):
      # I hope I don't store that ''resource_name'' string too many times.
      if not resource_name in self.resource_cache:
        self.resource_cache[resource_name] = self.ResourceCache(self, resource_name) 
      return self.resource_cache[resource_name]
      
      # Currently there's no clean up of this cache. :)
      # Oh well. Python will collect my garbage.
 
    def dump_object(self,obj, ident=""): 

      # Get resource name for object
      name = obj.resource_name
  
      # If object resource isn't "cached", do so.
      cached = self.cache_resource(name)

      #print cached.resource_schema
      #for attr,item in cached.resource_schema.items():
      #  for key,subitem in item.items():
      #    try:
      #      print "%s.%s => %s"%(attr, key, subitem)
      #    except UnicodeEncodeError, e:
      #      print "%s.%s => %s" %(attr,key,self.unicode_fallback(subitem))
      #return

      # Max length of attribute name: For indentation
      maxlen = len(max(cached.required_attrs + cached.optional_attrs, key=len)) +1

      for n in cached.required_attrs + cached.optional_attrs:
        try:
          out = getattr(obj, n)
        except Exception, e:
          if n in obj._attrs._attrs:
            out = obj._attrs._attrs[n]
            print obj._cmdb_server._get_dict(obj._cmdb_server._server + out)
          else:
            out = e
        # Print attribute
        try:
          print "%s%-*s %s" %(ident, maxlen, str(n) + ":", out)
        except UnicodeEncodeError, e:
          print "%s%-*s %s" %(ident, maxlen, str(n) + ":",  self.unicode_fallback(out))
          print "%s%-*s ^^^ ERRORNEOUS OUTPUT: Mangled" %(ident, maxlen, "")

        # If attribute is a Resource object, dump that resource object as well
        if isinstance(out, Resource):
          self.dump_object(out, "  %s" %(ident))

    def resolve_object(self, obj, attr = None):
      if attr == None:
        print attr
    
    def compile_output(self, output, obj):
      compiled = []
      
      cached = self.cache_resource(obj.resource_name)
      for attr in output:
        if isinstance(attr, list):
          this_obj = obj
          for this_attr in attr:
            if this_attr in this_obj.required_attrs or this_attr in this_obj.optional_attrs:
              this_obj = getattr(this_obj, this_attr)
            else:
              print "Die die die! No such attr in %s: %s" %(this_obj.resource_name, this_attr)
              exit(1)
          compiled += ["obj." + ".".join(attr)]
        else:
          if not (attr in obj.required_attrs or attr in obj.optional_attrs):
            print "Die die die! No such attr in %s: %s" %(obj.resource_name, attr)
            exit(1)
          compiled += ["obj." + attr]
      # EVAL!!! EVIL AND DANGEROUS HACK. HACK HACK HACK.
      return compile(', '.join(compiled), '<string>', 'eval')

###
# Some functions here

# Compile ''query''
# This is DIRTY. And: rather unsafe. :) Oh well.
###
# Setup argument parsing
parser = ArgumentParser(description='Drac drac drac drac!')
parser.add_argument("-r", "--resource", type=str, metavar="resource", help="Lookup specified resource.")
parser.add_argument("-k", "--key", type=str, metavar="key", help="Lookup using specified key.")
parser.add_argument("--flt", "-l", help="Field lookup type")

parser.add_argument("-R", "--reverse", help="Lookup reverse (serial?)", action="store_true")
parser.add_argument("-F", "--follow", help="Follow resources recursively", action="store_true")
parser.add_argument("-i", "--ignore-case", help="Ignore case in searches", action="store_true")
parser.add_argument("-E", "--regex", help="Use regex.", action="store_true")
parser.add_argument("-o", "--output", help="Output fields")
parser.add_argument("-O", "--format", help="Output field format")
parser.add_argument("-c", "--count", help="Print count", action="store_true")
parser.add_argument("--query-limit", help="cmdb ''query limit''", type=int)
parser.add_argument("--query-offset", help="cmdb ''query offset''", type=int)
parser.add_argument(
  'wordlist',
  metavar = 'word',
  nargs='*',
  help='Words to look up'
  )
parser.add_argument("--dump-resource", action="store_true", help="Dump resource attributes.")
parser.add_argument("--dump-api-base", help="Dump api base", action="store_true")
parser.add_argument("--dump-flt", help="Show ''field lookup types''", action="store_true")
parser.add_argument("--dump-object", help="Dump returned objects", action="store_true")


args = parser.parse_args()

###
# Program: begin!
client = CMDB.Client('http://cmdb.met.no', '/api/v2/')

resource = args.resource
if resource == None:
  resource = default_output.keys()[0]

if args.output != None:
  args.output = args.output.split(",")
  for idx, val in enumerate(args.output):
    # Ugh. I don't know python. :)
    tmp = val.split(".")
    if (len(tmp) > 1):
      args.output[idx] = tmp

# Type spørring
if args.flt:
  flt = args.flt
else:
  if args.regex or args.ignore_case:
    print "Ugh ugh. flt trumphs regex/ignore_case"

  if args.regex: 
    flt = 'regex'
  elif args.ignore_case:
    flt = 'icontains'
  else:
    flt = 'contains'

#  Dump resource
if args.dump_resource:
  print "Resource: %s" %(resource)
  rs = client.cache_resource(resource).resource_schema

  for attr in rs:
    print("  %s\n    %s (%s)"%(attr, rs[attr]["help_text"],rs[attr]["type"]))
  
  exit(0)

#  Dump api base
if args.dump_api_base:
  print "Api base, baby."
  api_base = client.server._api_base
  for resource in api_base:
    print(resource)
  
  exit(0)

#  Dump "field looku ptypes"
if args.dump_flt:
  print "Flt baby (field lookup type!)"
  print client.server.field_lookup_types
  exit(0)

resource_cache = client.cache_resource(resource)
resource_class = resource_cache.resource_class

# Select, as it were, 'key' attribute
if not args.key == None:
  key = "__".join(args.key.split(".")) # Ugh ugh ugh ug[h]ly
else:
  if args.reverse:
    try:
      key = reversal[resource]
    except KeyError, e:
      print "Resource %s has no reversal." %(resource)
      exit(1)
  else:
    key = resource_cache.display_name

# Assemble 'query' string
if not isinstance(flt, list):
  flt = [flt]
if not isinstance(key, list):
  key = [key]
query_key = "__".join(key + flt)

if args.output != None:
  output = args.output
else:
  try:
    output = default_output[resource]
  except KeyError, e:
    output = [resource_cache.display_name, resource_cache.pk]

if args.format == None:
  output_format = ": %s"*len(output)
  output_format = output_format[2:]
else:
  output_format = args.format

# Blurp
if not args.wordlist:
  args.wordlist = {None}

try:
  compiled_output = False
  for word in args.wordlist:

    # I've no idea whether this is "pythonic" or not.
    query = client.new_query(resource, **{query_key: word})

    query.set_limit = args.query_limit
    query.set_offset = args.query_offset
    query.make_ready()

    
    objects = 1
    try:
      while objects:
        objects = query.object_query()
        
        # Ugh I wish I could do "while objects = ..."
        if not isinstance(objects, list):
          break
        
        if args.count:
          print "Count: %d/%d" %(query.offset(), query.total_count())
        
        for obj in objects:
          obj = resource_cache.resource_class(client.server, obj)

          if not compiled_output:
            compiled_output = client.compile_output(output, obj)
       
          if args.dump_object:
            client.dump_object(obj)

          print output_format % eval(compiled_output)

    except KeyboardInterrupt:
      print "Uh oh."
      raise KeyboardInterrupt

except KeyboardInterrupt:
  print "^C"
exit(0)



# vim: syntax=python
