#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys
import os
import json


# Comments are for sissies.
# This is not done yet.

sys.path.append("%s/.." %(os.path.dirname(os.path.abspath(__file__)))) # Ho ho ho!

from argparse import ArgumentParser
from libcmdb2.core import CMDBServer

from cmdbtool import *

#parser.add_argument("-r", "--resource", type=str, metavar="resource", help="Lookup specified resource.")


parser = ArgumentParser(description='Rack tool')
#parser.add_argument("--rack", type=str, metavar="rack")
#parser.add_argument("--units", "-u", type=str)
parser.add_argument("-D", "--dump", action='append')
parser.add_argument("-n", "--no-reverse", dest='reverse', action='store_false', default=True,  help="Don't resolve rack items's hostnames.")

#parser.add_argument("-r", "--resource", type=str, metavar="resource", help="Lookup specified resource.")
#parser.add_argument("-F", "--follow", help="Follow resources recursively", action="store_true")

args, leftover = parser.parse_known_args()
try:

  client = CMDB.Client('http://cmdb.met.no', '/api/v2/')
  
  rackunit_resource_name = 'rackunit'
  rackunit_resource = client.cache_resource(rackunit_resource_name)
  rackunit_class = rackunit_resource.resource_class

  rack_resource_name = 'rack'
  rack_resource = client.cache_resource(rack_resource_name)
  rack_class = rack_resource.resource_class

  host_resource_name = 'host'
  host_resource = client.cache_resource(host_resource_name)
  host_class = host_resource.resource_class
  
  item_resource_name = 'item'
  item_resource = client.cache_resource(item_resource_name)
  item_class = item_resource.resource_class

except KeyboardInterrupt:
  print '^C'
  exit(1)


# Program: begin!
def __main__():
  try:
    for rack in leftover:
      rack_search = client.init_basic_search(rack_resource_name, ['name===%s'%(rack)]) 
      rack_query = client.new_query(rack_resource_name, **rack_search)
      rack_objects = True

      while rack_objects:
        rack_objects = rack_query.object_query()
       
        if not rack_objects:
          break

        for rack_obj in rack_objects:
          if args.dump and 'rack_json' in args.dump:
            print "*** dump rack_sjon:"
            print json.dumps(rack_obj, indent=2)
            print "***"

          rack_obj = rack_class(client.server, rack_obj)
          
          if args.dump and 'rack' in args.dump:
            print "*** dump rack:"
            client.dump_object(rack_obj) 
            print "*** stop rack dump"
          
          rackunit_search = client.init_basic_search(rackunit_resource_name, ['rack.id===%s'%(rack_obj.id)])
          #print_rack_query(client,client.new_query(rackunit_resource_name, **rackunit_search))
          print_rack_query_haxxs(client,client.new_query(rackunit_resource_name, **rackunit_search))

  except KeyboardInterrupt:
    print "^c"
    exit(1)

def print_rack_query_haxxs(client, query):
  reverse_names = {}
  objects = True
  while objects:
    objects = query.object_query()

    if not objects:
      break

    reverse = {}

    for obj in objects:
      item_dict = client.get_dict(obj['item'], -1)
      rack_dict = client.get_dict(obj['rack'], -1)
      if args.dump and 'item_json' in args.dump:
        print json.dumps(item_dict, indent=2)

      # Reverse, baby. :)
      if not item_dict['id'] in reverse:
        reverse[item_dict['id']] = None
        host_search = client.init_basic_search(host_resource_name, ['item.id===%s'%(item_dict['id'])])
        host_query = client.new_query(host_resource_name, **host_search)
        host_objects = host_query.object_query()
        for host_object in host_objects:
          if 'name' in host_object:
            reverse[item_dict['id']] = host_object['name']
 
      print "%s%s %s (%s) %s (%s)" %(
        rack_dict['name'],
        obj['ruid'], 
        
        reverse[item_dict['id']],
        item_dict['serial'], 
        item_dict['itemmodel']['name'],
        item_dict['itemmodel']['type']['name'])

     


__main__()



  #search = client.init_basic_search(resource, leftover)
  #query = client.new_query(resource, **search)
  #query.set_limit = args.query_limit
  #query.set_offset = args.query_offset
   
  #while objects:
  #    objects = query.object_query()
  #    # Ugh I wish I could do "while objects = ..."
  #    if not isinstance(objects, list):
  #      break
  #    for obj in objects:
  #      obj = resource_cache.resource_class(client.server, obj)
  #      if args.dump and 'object' in args.dump:
  #        client.dump_object(obj)
# vim: syntax=python
